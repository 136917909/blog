(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{362:function(e,t,r){"use strict";r.r(t);var a=r(43),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[e._v("#")]),e._v(" Vue生命周期")]),e._v(" "),r("h2",{attrs:{id:"beforecreate"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#beforecreate"}},[e._v("#")]),e._v(" beforeCreate")]),e._v(" "),r("p",[e._v("在实例初始化之后，"),r("strong",[e._v("数据观测（data observer）和event/watch事件")]),e._v("配置"),r("strong",[e._v("之前")]),e._v("被调用")]),e._v(" "),r("h2",{attrs:{id:"created"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#created"}},[e._v("#")]),e._v(" created")]),e._v(" "),r("p",[e._v("在实例创建完成后被立即调用。在这一步，实例已完成一下的配置：**数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。**然而，挂载阶段还没开始，"),r("code",[e._v("$el")]),e._v(" property 目前尚不可用。")]),e._v(" "),r("h2",{attrs:{id:"beforemount"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#beforemount"}},[e._v("#")]),e._v(" beforeMount")]),e._v(" "),r("p",[e._v("在挂载开始之前被调用：相关的"),r("strong",[e._v("render函数")]),e._v("首次被调用。")]),e._v(" "),r("p",[r("strong",[e._v("该钩子在服务器端渲染期间不被调用。")])]),e._v(" "),r("h2",{attrs:{id:"mounted"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mounted"}},[e._v("#")]),e._v(" mounted")]),e._v(" "),r("p",[e._v("实例被挂载后调用，这时 "),r("code",[e._v("el")]),e._v(" 被新创建的 "),r("code",[e._v("vm.$el")]),e._v(" 替换了。如果根实例挂载到了一个文档内的元素上，当 "),r("code",[e._v("mounted")]),e._v(" 被调用时 "),r("code",[e._v("vm.$el")]),e._v(" 也在文档内。")]),e._v(" "),r("p",[e._v("注意 "),r("code",[e._v("mounted")]),e._v(" "),r("strong",[e._v("不会")]),e._v("保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 "),r("code",[e._v("mounted")]),e._v(" 内部使用 "),r("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#vm-nextTick",target:"_blank",rel:"noopener noreferrer"}},[e._v("vm.$nextTick"),r("OutboundLink")],1),e._v("：")]),e._v(" "),r("h2",{attrs:{id:"beforeupdate"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#beforeupdate"}},[e._v("#")]),e._v(" beforeUpdate")]),e._v(" "),r("p",[e._v("数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。")]),e._v(" "),r("h2",{attrs:{id:"update"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[e._v("#")]),e._v(" update")]),e._v(" "),r("p",[e._v("由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。")]),e._v(" "),r("p",[e._v("当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用"),r("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#computed",target:"_blank",rel:"noopener noreferrer"}},[e._v("计算属性"),r("OutboundLink")],1),e._v("或 "),r("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#watch",target:"_blank",rel:"noopener noreferrer"}},[e._v("watcher"),r("OutboundLink")],1),e._v(" 取而代之。")]),e._v(" "),r("p",[e._v("注意 "),r("code",[e._v("updated")]),e._v(" "),r("strong",[e._v("不会")]),e._v("保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 "),r("code",[e._v("updated")]),e._v(" 里使用 "),r("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#vm-nextTick",target:"_blank",rel:"noopener noreferrer"}},[e._v("vm.$nextTick"),r("OutboundLink")],1),e._v("：")]),e._v(" "),r("h2",{attrs:{id:"activated"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#activated"}},[e._v("#")]),e._v(" activated")]),e._v(" "),r("p",[e._v("被 keep-alive 缓存的组件激活时调用。")]),e._v(" "),r("p",[r("strong",[e._v("该钩子在服务器端渲染期间不被调用。")])]),e._v(" "),r("h2",{attrs:{id:"deactivated"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#deactivated"}},[e._v("#")]),e._v(" deactivated")]),e._v(" "),r("p",[e._v("被 keep-alive 缓存的组件停用时调用。")]),e._v(" "),r("p",[r("strong",[e._v("该钩子在服务器端渲染期间不被调用。")])]),e._v(" "),r("h2",{attrs:{id:"beforedestroy"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#beforedestroy"}},[e._v("#")]),e._v(" beforeDestroy")]),e._v(" "),r("p",[e._v("实例销毁之前调用。在这一步，实例仍然完全可用。")]),e._v(" "),r("p",[r("strong",[e._v("该钩子在服务器端渲染期间不被调用。")])]),e._v(" "),r("h2",{attrs:{id:"destroyed"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#destroyed"}},[e._v("#")]),e._v(" destroyed")]),e._v(" "),r("p",[e._v("实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。")]),e._v(" "),r("p",[r("strong",[e._v("该钩子在服务器端渲染期间不被调用。")])]),e._v(" "),r("h2",{attrs:{id:"errorcaptured"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#errorcaptured"}},[e._v("#")]),e._v(" errorCaptured")]),e._v(" "),r("p",[e._v("当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 "),r("code",[e._v("false")]),e._v(" 以阻止该错误继续向上传播。")]),e._v(" "),r("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://cn.vuejs.org/images/lifecycle.png",alt:"Vue 实例生命周期"}})])}),[],!1,null,null,null);t.default=v.exports}}]);