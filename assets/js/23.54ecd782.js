(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{369:function(e,a,t){"use strict";t.r(a);var r=t(43),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"浏览器缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[e._v("#")]),e._v(" 浏览器缓存")]),e._v(" "),t("h2",{attrs:{id:"强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[e._v("#")]),e._v(" 强缓存")]),e._v(" "),t("p",[e._v("强缓存简单理解就是:给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期,浏览器需要重新请求。")]),e._v(" "),t("p",[t("strong",[e._v("强缓存主要是通过http请求头中的Cache-Control和Expires两个字段控制")]),e._v("。")]),e._v(" "),t("h4",{attrs:{id:"expires"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[e._v("#")]),e._v(" expires")]),e._v(" "),t("p",[e._v("expires是一个HTTP/1.0的字段,它给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。")]),e._v(" "),t("p",[t("strong",[e._v("用法:")])]),e._v(" "),t("p",[e._v("它描述的是一个"),t("strong",[e._v("绝对时间,用GMT格式的字符串表示")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Expires: Wed Feb 20 2019 11:25:41 GMT\n")])])]),t("p",[t("strong",[e._v("弊端:")])]),e._v(" "),t("p",[e._v("Expires返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入Cache-Control:max-age指令的原因之一。")]),e._v(" "),t("hr"),e._v(" "),t("h4",{attrs:{id:"cache-control-max-age"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cache-control-max-age"}},[e._v("#")]),e._v(" cache-control: max-age")]),e._v(" "),t("p",[e._v("为了解决expires存在的问题，Http1.1版本中提出了"),t("strong",[e._v("cache-control:max-age")]),e._v("，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是max-age设置的是"),t("strong",[e._v("相对缓存时间开始往后的多少秒，因此不再受日期不准确情况的影响。")])]),e._v(" "),t("p",[t("strong",[e._v("用法:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Cache-control: max-age=666\n")])])]),t("p",[t("strong",[e._v("优先级:")]),e._v("\n在优先级上:"),t("code",[e._v("max-age>Expires")]),e._v("。当两者同时出现在响应头时,Expires将被max-age覆盖.")]),e._v(" "),t("p",[t("strong",[e._v("用法:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Cache-control: max-age=666\n")])])]),t("p",[e._v("表示资源会在 666 秒后过期，需要再次请求。")]),e._v(" "),t("hr"),e._v(" "),t("h4",{attrs:{id:"强缓存在浏览器上的表现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强缓存在浏览器上的表现"}},[e._v("#")]),e._v(" 强缓存在浏览器上的表现")]),e._v(" "),t("ul",[t("li",[e._v("Firefox浏览器对强缓存表现为一个灰色的200状态码。")]),e._v(" "),t("li",[e._v("Chrome浏览器状态码表现为:"),t("code",[e._v("200 (from disk cache)或是200 OK (from memory cache)")])])]),e._v(" "),t("p",[e._v("但是强制缓存存在一个问题，该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源。这时怎么办?于是就有了协商缓存.")]),e._v(" "),t("h2",{attrs:{id:"协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),t("p",[e._v("协商缓存解决了无法及时获取更新资源的问题。它利用下面会讲到的两组字段,对资源做标识.然后由服务器做分析，如果资源未更新，则返回304状态码.那么浏览器则会从缓存中读取资源，否则重新请求资源。")]),e._v(" "),t("p",[t("strong",[e._v("协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。")])]),e._v(" "),t("h4",{attrs:{id:"last-modified与if-modified-since"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#last-modified与if-modified-since"}},[e._v("#")]),e._v(" Last-Modified与If-Modified-Since")]),e._v(" "),t("ul",[t("li",[e._v("1,浏览器第一次向服务器请求资源，服务器会在返回这个资源的同时，"),t("strong",[e._v("在response的header加上Last-Modified的header")]),e._v(",这个header表示这个资源在服务器上的最后修改时间："),t("code",[e._v("Last-Modified: Wed Feb 20 2019 14:08:32 GMT")])]),e._v(" "),t("li",[e._v("2,浏览器之后再向服务器请求这个资源时，"),t("strong",[e._v("在request的header上加上If-Modified-Since的header")]),e._v("，这个header的值就是上一次请求时返回的Last-Modified的值："),t("code",[e._v("Last-Modified: Wed Feb 20 2019 14:08:32 GMT")])]),e._v(" "),t("li",[e._v("3,服务器再次收到资源请求时，"),t("strong",[e._v("根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化")]),e._v("，如果没有变化则返回304 Not Modified，但是"),t("strong",[e._v("不会返回资源内容")]),e._v("；如果有变化,返回200，就正常返回资源内容。\n"),t("ul",[t("li",[t("strong",[e._v("当服务器返回304 Not Modified的响应时，response的header中不会再添加Last-Modified的header")]),e._v("，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header.")])])]),e._v(" "),t("li",[e._v("4,浏览器收到304的响应后，就会从缓存中加载资源。")]),e._v(" "),t("li",[e._v("5,浏览器收到200的响应后，则从服务器加载新资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。")])]),e._v(" "),t("p",[t("strong",[e._v("弊端:")]),e._v("\n【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是"),t("strong",[e._v("它们是以秒为单位进行更新，如果小于该单位高频进行更新的话，则不适合采用该方法。")]),e._v(" 这时候协商缓就不那么的可靠了。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。")]),e._v(" "),t("hr"),e._v(" "),t("h4",{attrs:{id:"etag与if-none-match"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#etag与if-none-match"}},[e._v("#")]),e._v(" ETag与If-None-Match")]),e._v(" "),t("ul",[t("li",[e._v("1,浏览器第一次跟服务器请求一个资源，"),t("strong",[e._v("服务器在返回这个资源的同时，在response的header加上ETag的header")]),e._v("，这个header是服务器"),t("strong",[e._v("根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串")]),e._v("，"),t("code",[e._v("ETag: shotcat-66666")]),e._v("只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题.")]),e._v(" "),t("li",[e._v("2,浏览器再次跟服务器请求这个资源时，"),t("strong",[e._v("在request的header上加上If-None-Match的header")]),e._v("，这个header的值就是上一次请求时返回的ETag的值"),t("code",[e._v("If-None-Match: shotcat-66666")]),e._v(".")]),e._v(" "),t("li",[e._v("3,服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，则返回200,并正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，"),t("strong",[e._v("由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化")])]),e._v(" "),t("li",[e._v("4,浏览器收到304的响应后，就会从缓存中加载资源。")]),e._v(" "),t("li",[e._v("5,浏览器收到200的响应后，则从服务器加载新资源时，ETag在重新加载的时候会被更新，下次请求时，If-None-Match会启用上次返回的ETag值。")])]),e._v(" "),t("p",[e._v("Etag和Last-Modified非常相似，都是用来判断一个参数，从而决定是否启用缓存。但是ETag相对于Last-Modified也有其优势，"),t("strong",[e._v("可以更加准确的判断文件内容是否被修改，")]),e._v(" 从而在实际操作中实用程度也更高,但缺点也很明显,"),t("strong",[e._v("由于需要对资源进行生成标识，性能方面就势必有所牺牲")]),e._v("。")]),e._v(" "),t("p",[t("strong",[e._v("优先级:")]),e._v(" "),t("strong",[e._v("ETag与If-None-Match > Last-Modified与If-Modified-Since,")]),e._v(" 同时存在时, 前者覆盖后者.")]),e._v(" "),t("h2",{attrs:{id:"启发式缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启发式缓存"}},[e._v("#")]),e._v(" 启发式缓存")]),e._v(" "),t("p",[e._v("我跟我们的请求头中确定缓存过期时间的字段一个都没有.例如:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Age:23146\nCache-Control: public\nDate:Tue, 28 Nov 2017 12:26:41 GMT\nLast-Modified:Tue, 28 Nov 2017 05:14:02 GMT\nVary:Accept-Encoding\n")])])]),t("p",[e._v("此时则会默认触发浏览器启发式缓存:\n"),t("strong",[e._v("浏览器会根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。")])]),e._v(" "),t("h2",{attrs:{id:"缓存的优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存的优先级"}},[e._v("#")]),e._v(" 缓存的优先级")]),e._v(" "),t("p",[e._v("在缓存策略上:强缓存>协商缓存>启发式缓存")]),e._v(" "),t("p",[e._v("进一步分析可得出,以下优先级：\nCache-Control > Expires > ETag > Last-Modified")]),e._v(" "),t("h4",{attrs:{id:"非常注意"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非常注意"}},[e._v("#")]),e._v(" "),t("strong",[e._v("非常注意")])]),e._v(" "),t("p",[e._v("其他所有教程都是告诉你浏览器肯定是先检查强缓存,再检查协商缓存!但实际它们都忽略了一点.其实浏览器是"),t("strong",[e._v("先检查Cache-Control,如果为no-store.则浏览器 所有内容都不会缓存，强制缓存，协商缓存统统都不会触发!!!")])]),e._v(" "),t("h4",{attrs:{id:"补充-pragma"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#补充-pragma"}},[e._v("#")]),e._v(" 补充:Pragma")]),e._v(" "),t("p",[e._v("它是HTTP/1.0里面的一个字段，在http1.1已被抛弃，使用Cache-Control替代.但为了做http协议的向下兼容，很多网站依旧会带上这个字段但优先级很高.")]),e._v(" "),t("p",[e._v("测试发现，Chrome和Firefox中Pragma的优先级高于Cache-Control和Expires.")]),e._v(" "),t("p",[e._v("一般可能会这么用："),t("code",[e._v('<meta http-equiv="Pragma" content="no-cache">')])]),e._v(" "),t("p",[e._v("服务端响应添加'Pragma': 'no-cache'，浏览器表现行为和强制刷新类似。")])])}),[],!1,null,null,null);a.default=s.exports}}]);